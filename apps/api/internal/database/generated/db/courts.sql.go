// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: courts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountCourts = `-- name: CountCourts :one
SELECT COUNT(*) FROM court
`

func (q *Queries) CountCourts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountCourts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateCourt = `-- name: CreateCourt :one
WITH new_location AS (
  INSERT INTO location (address_line, country_code, timezone, lat, lon, region, postal_code, place_id)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
  RETURNING id, address_line, country_code, timezone, lat, lon, region, postal_code, place_id, created_at, updated_at
), new_court AS (
  INSERT INTO court (location_id, name, court_count)
  VALUES ((SELECT id FROM new_location), $9, $10)
  RETURNING id, location_id, name, court_count, created_at, updated_at
)
SELECT
  c.id as court_id,
  c.location_id,
  c.name as court_name,
  c.court_count,
  c.created_at as court_created_at,
  c.updated_at as court_updated_at,
  l.id as location_id_val,
  l.address_line,
  l.country_code,
  l.timezone,
  l.lat,
  l.lon,
  l.region,
  l.postal_code,
  l.place_id,
  l.created_at as location_created_at,
  l.updated_at as location_updated_at
FROM new_court c
CROSS JOIN new_location l
`

type CreateCourtParams struct {
	AddressLine string         `json:"address_line"`
	CountryCode string         `json:"country_code"`
	Timezone    string         `json:"timezone"`
	Lat         pgtype.Numeric `json:"lat"`
	Lon         pgtype.Numeric `json:"lon"`
	Region      pgtype.Text    `json:"region"`
	PostalCode  pgtype.Text    `json:"postal_code"`
	PlaceID     pgtype.Text    `json:"place_id"`
	Name        string         `json:"name"`
	CourtCount  int32          `json:"court_count"`
}

type CreateCourtRow struct {
	CourtID           int64              `json:"court_id"`
	LocationID        int64              `json:"location_id"`
	CourtName         string             `json:"court_name"`
	CourtCount        int32              `json:"court_count"`
	CourtCreatedAt    pgtype.Timestamptz `json:"court_created_at"`
	CourtUpdatedAt    pgtype.Timestamptz `json:"court_updated_at"`
	LocationIDVal     int64              `json:"location_id_val"`
	AddressLine       string             `json:"address_line"`
	CountryCode       string             `json:"country_code"`
	Timezone          string             `json:"timezone"`
	Lat               pgtype.Numeric     `json:"lat"`
	Lon               pgtype.Numeric     `json:"lon"`
	Region            pgtype.Text        `json:"region"`
	PostalCode        pgtype.Text        `json:"postal_code"`
	PlaceID           pgtype.Text        `json:"place_id"`
	LocationCreatedAt pgtype.Timestamptz `json:"location_created_at"`
	LocationUpdatedAt pgtype.Timestamptz `json:"location_updated_at"`
}

func (q *Queries) CreateCourt(ctx context.Context, arg CreateCourtParams) (CreateCourtRow, error) {
	row := q.db.QueryRow(ctx, CreateCourt,
		arg.AddressLine,
		arg.CountryCode,
		arg.Timezone,
		arg.Lat,
		arg.Lon,
		arg.Region,
		arg.PostalCode,
		arg.PlaceID,
		arg.Name,
		arg.CourtCount,
	)
	var i CreateCourtRow
	err := row.Scan(
		&i.CourtID,
		&i.LocationID,
		&i.CourtName,
		&i.CourtCount,
		&i.CourtCreatedAt,
		&i.CourtUpdatedAt,
		&i.LocationIDVal,
		&i.AddressLine,
		&i.CountryCode,
		&i.Timezone,
		&i.Lat,
		&i.Lon,
		&i.Region,
		&i.PostalCode,
		&i.PlaceID,
		&i.LocationCreatedAt,
		&i.LocationUpdatedAt,
	)
	return i, err
}

const GetAllCourts = `-- name: GetAllCourts :many
SELECT
  c.id as court_id,
  c.location_id,
  c.name as court_name,
  c.court_count,
  c.created_at as court_created_at,
  c.updated_at as court_updated_at,
  l.id as location_id_val,
  l.address_line,
  l.country_code,
  l.timezone,
  l.lat,
  l.lon,
  l.region,
  l.postal_code,
  l.place_id,
  l.created_at as location_created_at,
  l.updated_at as location_updated_at
FROM court c
INNER JOIN location l ON c.location_id = l.id
ORDER BY c.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllCourtsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllCourtsRow struct {
	CourtID           int64              `json:"court_id"`
	LocationID        int64              `json:"location_id"`
	CourtName         string             `json:"court_name"`
	CourtCount        int32              `json:"court_count"`
	CourtCreatedAt    pgtype.Timestamptz `json:"court_created_at"`
	CourtUpdatedAt    pgtype.Timestamptz `json:"court_updated_at"`
	LocationIDVal     int64              `json:"location_id_val"`
	AddressLine       string             `json:"address_line"`
	CountryCode       string             `json:"country_code"`
	Timezone          string             `json:"timezone"`
	Lat               pgtype.Numeric     `json:"lat"`
	Lon               pgtype.Numeric     `json:"lon"`
	Region            pgtype.Text        `json:"region"`
	PostalCode        pgtype.Text        `json:"postal_code"`
	PlaceID           pgtype.Text        `json:"place_id"`
	LocationCreatedAt pgtype.Timestamptz `json:"location_created_at"`
	LocationUpdatedAt pgtype.Timestamptz `json:"location_updated_at"`
}

func (q *Queries) GetAllCourts(ctx context.Context, arg GetAllCourtsParams) ([]GetAllCourtsRow, error) {
	rows, err := q.db.Query(ctx, GetAllCourts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCourtsRow{}
	for rows.Next() {
		var i GetAllCourtsRow
		if err := rows.Scan(
			&i.CourtID,
			&i.LocationID,
			&i.CourtName,
			&i.CourtCount,
			&i.CourtCreatedAt,
			&i.CourtUpdatedAt,
			&i.LocationIDVal,
			&i.AddressLine,
			&i.CountryCode,
			&i.Timezone,
			&i.Lat,
			&i.Lon,
			&i.Region,
			&i.PostalCode,
			&i.PlaceID,
			&i.LocationCreatedAt,
			&i.LocationUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCourtStatus = `-- name: GetCourtStatus :one
SELECT
  cs.court_id,
  cs.courts_occupied,
  cs.groups_waiting
FROM court_status cs
WHERE cs.court_id = $1
`

type GetCourtStatusRow struct {
	CourtID        int64 `json:"court_id"`
	CourtsOccupied int32 `json:"courts_occupied"`
	GroupsWaiting  int32 `json:"groups_waiting"`
}

func (q *Queries) GetCourtStatus(ctx context.Context, courtID int64) (GetCourtStatusRow, error) {
	row := q.db.QueryRow(ctx, GetCourtStatus, courtID)
	var i GetCourtStatusRow
	err := row.Scan(&i.CourtID, &i.CourtsOccupied, &i.GroupsWaiting)
	return i, err
}

const GetCourtStatusBatch = `-- name: GetCourtStatusBatch :many
SELECT
  cs.court_id,
  cs.courts_occupied,
  cs.groups_waiting
FROM court_status cs
WHERE cs.court_id = ANY($1::bigint[])
`

type GetCourtStatusBatchRow struct {
	CourtID        int64 `json:"court_id"`
	CourtsOccupied int32 `json:"courts_occupied"`
	GroupsWaiting  int32 `json:"groups_waiting"`
}

func (q *Queries) GetCourtStatusBatch(ctx context.Context, dollar_1 []int64) ([]GetCourtStatusBatchRow, error) {
	rows, err := q.db.Query(ctx, GetCourtStatusBatch, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCourtStatusBatchRow{}
	for rows.Next() {
		var i GetCourtStatusBatchRow
		if err := rows.Scan(&i.CourtID, &i.CourtsOccupied, &i.GroupsWaiting); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const InsertCourtStatus = `-- name: InsertCourtStatus :one
INSERT INTO court_status (court_id, courts_occupied, groups_waiting)
VALUES ($1, $2, $3)
RETURNING court_id, courts_occupied, groups_waiting, created_at, updated_at
`

type InsertCourtStatusParams struct {
	CourtID        int64 `json:"court_id"`
	CourtsOccupied int32 `json:"courts_occupied"`
	GroupsWaiting  int32 `json:"groups_waiting"`
}

type InsertCourtStatusRow struct {
	CourtID        int64              `json:"court_id"`
	CourtsOccupied int32              `json:"courts_occupied"`
	GroupsWaiting  int32              `json:"groups_waiting"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) InsertCourtStatus(ctx context.Context, arg InsertCourtStatusParams) (InsertCourtStatusRow, error) {
	row := q.db.QueryRow(ctx, InsertCourtStatus, arg.CourtID, arg.CourtsOccupied, arg.GroupsWaiting)
	var i InsertCourtStatusRow
	err := row.Scan(
		&i.CourtID,
		&i.CourtsOccupied,
		&i.GroupsWaiting,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateCourtStatus = `-- name: UpdateCourtStatus :one
UPDATE court_status
SET
  courts_occupied = $2,
  groups_waiting = $3
WHERE court_id = $1
RETURNING court_id, courts_occupied, groups_waiting, created_at, updated_at
`

type UpdateCourtStatusParams struct {
	CourtID        int64 `json:"court_id"`
	CourtsOccupied int32 `json:"courts_occupied"`
	GroupsWaiting  int32 `json:"groups_waiting"`
}

type UpdateCourtStatusRow struct {
	CourtID        int64              `json:"court_id"`
	CourtsOccupied int32              `json:"courts_occupied"`
	GroupsWaiting  int32              `json:"groups_waiting"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateCourtStatus(ctx context.Context, arg UpdateCourtStatusParams) (UpdateCourtStatusRow, error) {
	row := q.db.QueryRow(ctx, UpdateCourtStatus, arg.CourtID, arg.CourtsOccupied, arg.GroupsWaiting)
	var i UpdateCourtStatusRow
	err := row.Scan(
		&i.CourtID,
		&i.CourtsOccupied,
		&i.GroupsWaiting,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
